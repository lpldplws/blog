# 传输层

传输层协议中最常见的是TCP协议和UDP协议。

![大纲](http://h0.beicdn.com/open202013/a8be0f18807f9127_1456x818.jpg)

## TCP协议和UDP协议简介及适用场景

与UDP相比，TCP的主要区别包括：

- 面向连接全双工。所谓的连接，指的是客户端和服务器的连接，在双方互相通信之前，TCP 需要三次握手建立连接，四次挥手断开连接，而 UDP 没有相应建立连接的过程。
- 可靠性。TCP 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这是**有状态**。当意识到丢包了或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是**可控制**。
- 面向字节流。UDP 的数据传输是基于数据报的，这是因为仅仅只是继承了 IP 层的特性，而 TCP 为了维护状态，将一个个 IP 包变成了字节流。

根据特点，TCP更适用于安全系数要求高，传输质量有保障，时延要求不敏感的环境；UDP更适合安全系数低，时延敏感的环境，如视频

## TCP建立连接的过程

TCP采用三次握手的机制。

三次握手是为了保证发送方和接收方都有发送和接收报文的能力。

这里需要注意的是，在TCP报文中，SYN（synchronous）和ACK（acknowledgement）都是1bit的位标识符，为1标识true。

```
第一次握手：主机A发送位码为SYN＝1，随机产生seq number=XXX的数据包到服务器，主机B由SYN=1知道，A要求建立连接，此时A为SYN SENT阶段；

第二次握手：主机B收到请求后要确认连接的信息，向A发送ack number=(主机A的seq number + 1)，SYN=1，ACK=1，随机产生seq number=YYY的包，此时B为SYN RCVD的阶段；

第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码ACK是否为1，若正确，A为ESTABLIISH阶段，主机A会再发送ack number=(主机B的seq+1)与下一个seq number(为下一个seq number + 1)，ACK=1，主机B收到后确认seq值与ACK=1，则为ESTABLISH，连接建立成功。
```

![三次握手](https://user-gold-cdn.xitu.io/2020/2/23/170723de9b8aa08b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 为什么不是2次握手，或者4次握手

其实所有的TCP连接都可以根据上图来分析，如果是两次连接，第三次的ACK延迟传到服务端，没有证明客户端有**接受报文**的能力。
可两次连接这时候会认为已经建立连接，假如服务端返回的报文一致发送，客户端没有接受到，就会导致服务端资源浪费。至于四次握手，还是那句话，只要证明客户端和服务端有能力接受发送报文，就没有什么问题。

### 若客户端和服务端一起发送报文

按照上面的流程，只要建立连接即可，最后客户端和服务端会一起进入ESTABLISH阶段。（图片最后还差一步ACK的过程）。

![客户端服务端一起发送报文](https://user-gold-cdn.xitu.io/2020/2/23/170723e219f0a415?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## TCP断开连接的过程

```
第一次挥手：主机A发送位码为FIN＝1，生成seq number=XXX的结束请求报文；

第二次挥手：主机B收到请求后要告诉主机A，我接收到结束报文，返回ACK，ack number=XXX+1；

第三次挥手：主机B向主机A发送FIN，ack number=XXX+1(证明是对于seq number=XXX的响应报文)与seq number = YYY的报文

第四次挥手：主机A在等待2个MSL(Maximum Segment Lifetime，报文最大生存时间)后，在这段时间内如果客户端没有收到服务端的重发请求，那么表示ACK成功到达，ack number=YYY+1。
```

![断开连接](https://user-gold-cdn.xitu.io/2020/2/23/170723e5c0e05829?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 为什么最后一次挥手是2个MSL

- 1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端
- 1 个 MSL 确保对端没有额外的报文返回

### 为什么不是三次挥手或者五次挥手

在第三次挥手的时候，服务端需要保证报文全部发送完毕。如果服务端将ACK和FIN的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN。

五次挥手同上，没有必要。

### 同时关闭的情况

![同时发送关闭报文](https://user-gold-cdn.xitu.io/2020/2/23/170723edeb9e8003?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 半连接队列&全连接队列

在三次握手中，当客户端发送SYN到服务端，服务端收到以后回复ACK和SYN，状态由LISTEN变为SYN_RCVD，此时这个连接就被推入了SYN队列，也就是**半连接队列**。

当客户端返回ACK, 服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走之前，它会被推入另外一个 TCP 维护的队列，也就是**全连接队列**。

### SYN flood攻击

SYN Flood 属于典型的 DoS/DDoS 攻击。

其攻击的原理很简单，就是用客户端在短时间内伪造大量不存在的 IP 地址，并向服务端疯狂发送SYN。对于服务端而言，会产生两个危险的后果:

- 处理大量的SYN包并返回对应ACK, 势必有大量连接处于SYN_RCVD状态，从而占满整个半连接队列，无法处理正常的请求。
- 由于是不存在的 IP，服务端长时间收不到客户端的ACK，会导致服务端不断重发数据，直到耗尽服务端的资源。

### 如何应对SYN flood

- 增加半连接队列长度
- 减少 SYN + ACK 重试次数，避免大量的超时重发
- 利用 SYN Cookie 技术，在服务端接收到SYN后不立即分配连接资源，而是根据这个SYN计算出一个Cookie，连同第二次握手回复给客户端，在客户端回复ACK的时候带上这个Cookie值，服务端验证 Cookie 合法之后才分配连接资源。

## TCP报文内容

结构如下：(单位为字节)

![TCP结构](https://user-gold-cdn.xitu.io/2020/2/23/170723f106ff0306?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- 源端口、目标端口：用来区分唯一连接：源IP，源端口，目标IP，目标端口。其中源IP和目标IP在网络层封装
- 序列号：为seq number，长度为4字节，范围为0~2^32，如果到达最大值了后就循环到0。
  作用为：
  1. 作为SYN的seq number标识
  2. 保证报文的有序传输
- 确认号：用来告知对方下一个期望接收的序列号，小于ACK的所有字节已经全部收到。
- 标记位：6bit有URG,SYN,ACK,FIN,RST,PSH。
  URG：即Urgent，表示紧急指针是否有效。
  RST：即 Reset，表示要求对方重新建立连接。
  PSH：即 Push， 告知对方这些数据包收到后应该马上交给上层的应用，不能缓存。
- 头部长度：4bit，标识当前报文的头部有多少个
- 保留：6bit
- 窗口大小：16bit，用于流量控制，由16bit组成，表示最多可容纳多少字节内容。本质上是描述接受方的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据。如果发送方收到接受方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接受方发送窗口大小不为0的数据报的到来。注意，TCP引入了窗口缩放的选项，作为窗口缩放的比例因子，这个比例因子的范围在 0 ~ 14，比例因子可以将窗口的值扩大为原来的 2 ^ n 次方。
- 校验和：判断是否有坏包，有的话重传
- 紧急指针：URG 配合紧急指针，就可以找到紧急数据的字节号
- 可选项：长宽缩放值就在其中

##  TCP快速打开（TCP Fast Open，TFO）

在使用TFO之前，client首先需要通过一个普通的三次握手连接获取FOC(Fast Open Cookie)

第一次握手
- client发送一个带有Fast Open选项的SYN包，同时携带一个空的cookie域来请求一个cookie
- server产生一个cookie，然后通过SYN-ACK包的Fast Open选项来返回给client
- client缓存这个cookie以备将来使用TFO连接的时候使用

之后的握手，执行TFO
- client发送一个带有数据的SYN包，同时在Fast Open选项中携带之前通过正常连接获取的cookie
- server验证这个cookie。如果这个cookie是有效的，server会返回SYN-ACK报文，然后这个server把接收到的数据传递给应用层。如果这个cookie是无效的，server会丢掉SYN包中的数据，同时返回一个SYN-ACK包来确认SYN包中的系列号
- 如果cookie有效，在连接完成之前server可以给client发送响应数据
- client发送ACK包来确认server的SYN和数据，如果client端SYN包中的数据没有被服务器确认，client会在这个ACK包中重传对应的数据
- 剩下的连接处理就类似正常的TCP连接了，client一旦获取到FOC，可以重复Fast Open直到cookie过期。

### TFO的优势

在拿到客户端的 Cookie 并验证通过以后，可以直接返回 HTTP 响应，充分利用了1 个RTT(Round-Trip Time，往返时延)的时间提前进行数据传输，积累起来还是一个比较大的优势。

## TCP报文，选项timestamp的作用

timestamp选项的结构

> name(1 字节) + length(1 字节) + info(8 字节)

其中info由timestamp和timestamp echo组成，各4字节

作用：

- 计算往返时延 RTT(Round-Trip Time)
- 防止序列号的回绕问题

### 计算往返时延 RTT

在计算RTT时，会有以下的情况

![RTT异常](https://user-gold-cdn.xitu.io/2020/2/23/170723fdfe450dc8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

第一个RTT计算时间过长，第二个RTT计算时间过短

1. a 向 b 发送的时候，timestamp 中存放的内容就是 a 主机发送时的内核时刻 ta1。
2. b 向 a 回复 s2 报文的时候，timestamp 中存放的是 b 主机的时刻 tb, timestamp echo字段为从 s1 报文中解析出来的 ta1。
3. a 收到 b 的 s2 报文之后，此时 a 主机的内核时刻是 ta2, 而在 s2 报文中的 timestamp echo 选项中可以得到 ta1, 也就是 s2 对应的报文最初的发送时刻。然后直接采用 ta2 - ta1 就得到了 RTT 的值。

### 防止序列号的回绕问题

序列号会在0~2^32循环，假如有一个报文滞留在网路中，跟下一个循环的包一起发送，seq number就会一致了。这时可以根据timestamp判断。

## TCP 的超时重传时间是如何计算的

TCP 具有超时重传机制，即间隔一段时间没有等到数据包的回复时，重传这个数据包

这个重传间隔也叫做超时重传时间(Retransmission TimeOut, 简称RTO)

### 经典方法

经典方法引入了一个新的概念——SRTT(Smoothed round trip time，即平滑往返时间)，每产生一次新的 RTT. 就根据一定的算法对 SRTT 进行更新，具体而言，计算方式如下(SRTT 初始值为0):

```JS
SRTT =  (α * SRTT) + ((1 - α) * RTT)
```

α 是平滑因子，建议值是0.8，范围是0.8 ~ 0.9。

```JS
RTO = min(ubound, max(lbound, β * SRTT))
```

β 是加权因子，一般为1.3 ~ 2.0， lbound 是下界，ubound 是上界。

适用于在RTT稳定的情况下使用。

### 标准方法

第一步也是

```JS
SRTT = (1 - α) * SRTT + α * RTT
```

其中，α建议值为1/8。

第二步: 计算RTTVAR(round-trip time variation)这个中间变量。

```JS
RTTVAR = (1 - β) * RTTVAR + β * (|RTT - SRTT|)
```

β 建议值为 0.25。这个值是这个算法中出彩的地方，也就是说，它记录了最新的 RTT 与当前 SRTT 之间的差值，给我们在后续感知到 RTT 的变化提供了抓手。

第三步: 计算最终的RTO:

```JS
RTO = µ * SRTT + ∂ * RTTVAR 
```
µ建议值取1, ∂建议值取4。

了解算法即可。

## TCP流量控制

如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。

由于TCP/IP支持全双工传输，因此通信的双方都拥有两个滑动窗口，一个用于接受数据，称之为接收窗口；一个用于发送数据，称之为发送窗口。

接收方在发送确认报文的时候，会告诉发送发自己的接收窗口大小，而发送方的发送窗口会据此来设置自己的发送窗口，但这并不意味着他们就会相等。首先接收方把确认报文发出去的那一刻，就已经在一边处理堆在自己缓存区的数据了，所以一般情况下接收窗口 >= 发送窗口。

当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。

为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。

![流量控制](https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIOiaD8iaf8gpnDuSDXqzickq9pnqfIvSXJmw2E1hoyFI5nKgLf6UK2YHVwO4xKKicL2Gexh9ic96BPG96w/640)

## TCP的拥塞控制

拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。

拥塞控制包括：慢启动，拥塞避免，快速重传，快速恢复

### 慢启动

发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。

每经历一个RTT，cwnd就加倍，为了防止cwnd增长过大引起网络拥塞，还需设置一个慢启动门限ssthresh状态变量。ssthresh的用法如下：

> 当cwnd < ssthresh时，使用慢启动算法。
> 
> 当cwnd>ssthresh时，改用拥塞避免算法。
> 
> 当cwnd=ssthresh时，慢开始与拥塞避免算法任意

这里的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，然后逐渐增大，这当然比按照大的cwnd一下子把许多报文段突然注入到网络中要“慢得多”。

### 拥塞避免

拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。

无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限ssthresh设置为出现拥塞时的发送窗口大小的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。

流程如下：

![慢启动与拥塞避免](https://pic3.zhimg.com/80/v2-f7db63b1f00cbd8170e1435616e06216_1440w.jpg)

### 快重传算法

发送方只要一连收到三个重复ack number就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

![快重传](https://pic3.zhimg.com/80/v2-c72fce5494ca8ee12244189430f12cea_1440w.jpg)

### 快恢复算法

当发送方连续收到三个重复确认时，把ssthresh门限减半（为了预防网络发生拥塞）。但是接下去并不执行慢开始算法。

考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢启动算法，而是将cwnd设置为ssthresh减半后的值，然后执行拥塞避免算法，使cwnd线性增长。

![快恢复](https://pic4.zhimg.com/80/v2-5f4034bc11c3a48a1d1a115f9ee0259b_1440w.jpg)

在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用

## 如何理解 TCP 的 keep-alive

客户端端等待超过一定时间后自动给服务端发送一个空的报文，如果对方回复了这个报文证明连接还存活着，如果对方没有报文返回且进行了多次尝试都是一样，那么就认为连接已经丢失，客户端就没必要继续保持连接了。如果没有这种机制就会有很多空闲的连接占用着系统资源。

功能同心跳包。

## UDP介绍

UDP传输与IP传输非常类似。你可以将UDP协议看作IP协议暴露在传输层的一个接口。UDP协议同样以数据包的方式传输，它的传输方式也是"Best Effort"的，所以UDP协议也是不可靠的。

那么，我们为什么不直接使用IP协议而要额外增加一个UDP协议呢？ 一个重要的原因是IP协议中并没有端口(port)的概念。IP协议进行的是IP地址到IP地址的传输，这意味者两台计算机之间的对话。但每台计算机中需要有多个通信通道，并将多个通信通道分配给不同的进程使用。

UDP头部如下：

![报文结构](https://www.linuxidc.com/upload/2018_09/180924145972611.jpg)

UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。

其中，源端口和目的端口均为2字节，因为UDP不需要应答，所以来源端口是可选的，如果来源端口不用，那么置为零。

长度为报文（包括数据部分）整体的长度。

检验和提供了差错校验的能力。

除此之外，因为不需要一对一建立连接，所以可以进行广播，支持一对一，一对多，多对一和多对多交换通信。