# promise基本使用

## 通过例子理解promise

JavaScript是单线程的，为了实现多线程，最先使用事件及回调解决。

```JS
var img1 = document.querySelector('.img-1');

function loaded() {
  // image loaded
}

if (img1.complete) {
  loaded();
}
else {
  img1.addEventListener('load', loaded);
}

img1.addEventListener('error', function() {
  // argh everything's broken
});
```
以上事件会在事情触发后执行，但会带来两个问题：

1. 如果在图片出错前绑定事件，错误就无法监听到；
2. 对于多张图片按序加载或判断加载成功或失败，以上的判断都过于复杂；

我们希望比较理想的伪代码如下：

```JS
img1.callThisIfLoadedOrWhenLoaded(function() {
  // loaded
}).orIfFailedCallThis(function() {
  // failed
});

// and…
whenAllTheseHaveLoaded([img1, img2]).callThis(function() {
  // all loaded
}).orIfSomeFailedCallThis(function() {
  // one or more failed
});
```

以上方法就是类promise的实现，如果我们把图片的加载写成一个可以返回promise的“ready”，以上代码用promise实现就是：
```JS
img1.ready().then(function() {
  // loaded
}, function() {
  // failed
});

// and…
Promise.all([img1.ready(), img2.ready()]).then(function() {
  // all loaded
}, function() {
  // one or more failed
});
```

相对于事件监听器，promise有以下两点不同：

1. promise的状态是不可逆的，只可以成功或失败一次；
2. 如果添加了已解决状态的回调，就会按照对应回调正确执行；

## promise基本术语

- 已执行(resolve)：promise执行操作成功；
- 已拒绝(reject)：promise执行操作失败；
- 待定(pending)：尚未执行或拒绝；
- 已解决(fulfill)：已执行或拒绝

其中，promise与相应类库都符合名为promise/A+的常见化标准行为，promise/A+标准行为见[补充文档]()


